# MySQL索引原理

## 索引的基本概念与作用

索引是数据库中用于加速数据查询的一种数据结构。通过索引，我们可以快速定位到需要查询的数据，从而显著提高查询效率。索引作为数据库的重要优化手段，对于提升系统性能具有关键作用。

## 索引的常见模型

在实际应用中，索引有多种实现模型，主要包括 B+ 树、哈希表、有序数组等。不同的模型适用于不同的场景，各有其优缺点。

### 1. 搜索树索引

搜索树索引基于搜索树数据结构实现，其核心特点是：父节点的左子树所有节点的值小于父节点的值，右子树所有节点的值大于父节点的值。

为了维持 O(log(n)) 的查询性能，需要保持这棵树的平衡，因此更新的时间复杂度也是 O(log(n))。

### 2. 哈希表索引

哈希表索引采用 key-value 存储结构，只需要输入待查找的 key，就可以直接获取对应的 value。其实现思路是：使用哈希函数将 value 计算成一个 key 值，然后将 value 存储在数组的对应位置，即 `arr[key] = value`。

**优点：**
- 查询性能基本为 O(1)，查询速度快
- 插入和更新性能好，只需要计算哈希值并插入到对应位置即可

**局限性：**
- **哈希冲突问题**：当哈希函数对多个值计算出同一个 key 时，称为哈希冲突。常见的处理方法是使用链表（Java 中的 HashMap 就是采用这种思路）
- **仅支持等值查询**：只适用于精确匹配查询，比如 `ID=2`。对于范围查询（如 `ID BETWEEN 1 AND 1000`），则无法支持

### 3. 有序数组索引

有序数组索引通过维护一个有序的数组来实现，仅适用于静态存储引擎（数据不会再修改的场景）。如果数据需要修改，则需要进行重新排序。

**优点：**
- 利用二分法，查询性能为 O(log(n))，查询速度快
- 支持范围查询

**局限性：**
- 插入和更新性能差：因为需要维护有序性，插入和更新操作需要移动大量数据

## InnoDB 的索引模型

InnoDB 存储引擎使用 **B+ 树**作为索引的数据结构。下面通过一个示例来理解 InnoDB 的索引模型：

假设有一个主键列为 ID 的表，表中有字段 k，且 k 上有索引，对应的建表语句如下：

```sql
mysql> CREATE TABLE T(
    id INT PRIMARY KEY, 
    k INT NOT NULL, 
    name VARCHAR(16),
    INDEX (k)
) ENGINE=InnoDB;
```

表中 R1~R5 的 (ID, k) 值分别为 (100, 1), (200, 2), (300, 3), (500, 5), (600, 6)。这两棵索引树的示意图如下：

![两棵树示意图](./image/两棵树示意图.webp)

根据叶子节点的内容，索引类型可分为：

- **主键索引（聚集索引）**：叶子节点存储的是完整的记录值
- **非主键索引（二级索引）**：叶子节点存储的是对应的主键值

在 InnoDB 中，主键索引也被称为**聚集索引**，非主键索引被称为**二级索引**或**辅助索引**。

## 主键索引 vs 非主键索引的查询差异

### 主键索引查询

如果语句是 `SELECT * FROM T WHERE ID=500`，即使用主键索引查询：

- 只需要搜索 ID 这一棵 B+ 树
- 找到对应的叶子节点后，直接返回完整的记录

### 非主键索引查询（回表）

如果语句是 `SELECT * FROM T WHERE k=5`，即使用非主键索引查询：

1. 先搜索 k 索引树，找到 k=5 对应的主键值（ID=500）
2. 再到 ID 索引树搜索一次，获取完整的记录

这个过程称为**回表**（Back to Table）。

### 性能对比

基于非主键索引的查询需要多扫描一棵索引树，性能开销更大。因此，在应用中应该**尽量使用主键查询**。

## 索引维护机制

B+ 树为了维护索引的有序性，在插入新值时需要进行必要的维护操作。

### 页分裂（Page Split）

以示例数据为例：

- **简单场景**：如果插入新行 ID=700，只需要在 R5 的记录后追加一个新记录
- **复杂场景**：如果插入 ID=400，则需要逻辑上挪动后面的数据，空出位置
- **最坏情况**：如果 R5 所在的数据页已经满了，根据 B+ 树的算法，需要：
  1. 申请一个新的数据页
  2. 将部分数据挪动到新页中

这个过程称为**页分裂**，会显著影响性能。

### 页合并（Page Merge）

页分裂的逆过程称为**页合并**。当相邻两个页由于删除了数据，利用率太低之后，会将这两个页的数据合并到一起。

### 页分裂的影响

除了性能影响外，页分裂操作还会影响数据页的利用率：

- 原本放在一个页的数据，现在分到两个页中
- 整体空间利用率降低约 50%

## 主键选择的最佳实践

基于索引维护的特点，我们需要审慎选择主键类型。下面分析自增主键和业务字段主键的优劣。

### 自增主键的优势

**定义**：自增主键是在自增列上定义的主键，插入新记录时可以不指定 ID 的值，系统会自动获取当前 ID 最大值加 1 作为下一条记录的 ID 值。

**优势：**

1. **有序插入，性能更优**
   - 自增主键的插入模式是递增插入，每次插入都是追加操作
   - 不涉及挪动其他记录，也不会触发叶子节点的分裂

2. **存储空间更小**
   - 每个非主键索引的叶子节点都存储主键的值
   - 使用整型（4 字节）或长整型（8 字节）做主键，相比使用字符串（如身份证号约 20 字节）做主键，可以显著降低二级索引的存储空间
   - 主键长度越小，普通索引的叶子节点就越小，占用的空间也就越小

### 业务字段主键的劣势

使用有业务逻辑的字段（如身份证号、邮箱等）做主键：

- 往往不容易保证有序插入，写数据成本相对较高
- 如果字段长度较长，会导致二级索引占用大量空间

### 结论

从**性能**和**存储空间**两个维度考量，**自增主键往往是更合理的选择**。

> 当然，事无绝对，具体场景需要具体分析。例如，如果表的查询主要依赖某个唯一业务字段，且该字段长度较短，也可以考虑使用该字段作为主键。

## 小结

1. **索引类型**：InnoDB 的索引分为主键索引（聚集索引）和非主键索引（二级索引）。主键索引叶子节点直接存储整行数据，二级索引则存储主键值作为引用。

2. **查询效率**：主键查询时仅需查找一棵 B+ 树，非主键索引查询则需"回表"，即先查索引再根据主键检索真实数据，效率更低。

3. **索引维护**：B+ 树在插入、删除过程中会发生页分裂、页合并，以维持有序性和空间利用率，这些操作会影响性能和存储。

4. **主键选择**：建议优先采用自增主键。自增主键插入有序，减少 B+ 树分裂，写入性能更优，也能降低二级索引占用空间。

5. **注意事项**：若使用较长的字符串或有业务逻辑的字段作主键，会导致普通索引空间占用大增，也会影响更新、维护的性能。

**总结**：选择合适的主键类型和索引结构，对于提升 MySQL 数据表的性能和空间利用率非常关键。


