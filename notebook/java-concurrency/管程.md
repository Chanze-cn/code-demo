# 管程（Monitor）

## 管程的定义

管程是一种同步机制，用于解决并发编程中的同步问题。它是一种高级同步原语，用于实现线程之间的同步和互斥。

## 管程的实现

管程的实现通常使用锁和条件变量来实现：
- **锁（Lock）**：用于实现互斥，保证同一时刻只有一个线程进入管程
- **条件变量（Condition）**：用于实现同步，让线程在特定条件下等待或唤醒

## 管程的优点

- 简单易用：封装了同步细节，用户只需关注业务逻辑
- 性能高：相比低级同步原语，减少了上下文切换的开销
- 可靠性高：避免了死锁、活锁等并发问题


## 管程模型

### MESA模型

MESA(Monitor Extended for Strengthened Access)模型是一种管程模型，用于实现线程之间的同步和互斥。以下为MESA模型示意图：

![MESA模型示意图](./image/管程模型.webp)

管程要求同一时刻只有一条线程在管程中执行，其他线程必须等待。**当线程T2的操作使线程T1等待的条件满足时，T1和T2究竟谁可以执行？**

### 三种管程模型对比

#### 1. Hasen模型

- **特点**：要求`notify()`放在代码的最后
- **执行流程**：T2通知完T1后，T2就结束了，然后T1再执行
- **优点**：保证同一时刻只有一个线程执行
- **缺点**：限制了`notify()`的使用位置

#### 2. Hoare模型

- **特点**：T2通知完T1后，T2阻塞，T1马上执行；等T1执行完，再唤醒T2
- **优点**：保证同一时刻只有一个线程执行
- **缺点**：相比Hasen模型，**需要多一次阻塞唤醒操作**

#### 3. MESA模型（推荐）⭐

- **特点**：T2通知完T1后，T1并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列中
- **优点**：
  - `notify()`可以放在代码任意位置
  - T2没有多余的阻塞唤醒操作
  - 性能更好
- **缺点**：T1再次执行时，可能曾经满足的条件已经不满足了
- **解决方案**：**需要以循环方式检验条件变量**，而不是`if`判断


## 参考代码

[使用管程的方式实现一个线程安全的队列](../../java-concurrency/src/main/java/cn/chanze/monitor/BlockQueue.java)

实现了基于ReentrantLock和Condition的阻塞队列，展示MESA管程模型在实际项目中的应用。

## 关键要点总结

1. **管程是高级同步原语**：通过锁实现互斥，通过条件变量实现同步
2. **MESA模型是Java的实现方式**：灵活、性能好，但需要循环检查条件
3. **循环判断条件**：避免使用`if`，使用`while`确保条件的正确性
4. **实践应用**：Java中的`synchronized`、`ReentrantLock`和`Condition`都是管程的实现

## 实践建议

- ✅ 优先使用`ReentrantLock`和`Condition`实现复杂同步逻辑
- ✅ 条件判断必须使用`while`循环，不能使用`if`
- ✅ 理解MESA模型的特点，避免常见并发问题
- ✅ 合理使用`signalAll()`和`signal()`进行线程唤醒

---

## 参考资料

- 极客时间《Java并发编程实战》课程
- Java并发编程包（java.util.concurrent）