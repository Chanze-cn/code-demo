# MySQL的重要日志文件
mysql的重要日志文件包括redolog日志文件和binlog日志文件。

# 重要的日志文件：redolog日志


redolog日志文件是InnoDB引擎内置的日志文件，属于引擎层的日志文件，当一条记录要更新的时候，InnoDB引擎会先写到redo log日志文件里面，并更新内存，这个时候就算更新完成了。同时，InnoDB会在适当的时候，将redo log日志文件中的内容刷新到磁盘文件中。redo log日志文件用于保证MySQL宕机后，数据可以恢复到宕机前的状态。

## redo log日志文件的结构

![redo log日志文件的结构](../image/mysql/mysql日志体系/redolog模型示意图.webp)

redo log日志文件是一个循环队列，会有两个指针，一个指向队头一个指向队尾，队头到队尾之间就是redo log的日志内容，当队尾指针等于队头-1 时，表示队列满了；当队尾指针等于队头时，表示队列空了。写redo log日志文件的时候，移动队尾指针，将redo log日志文件的内容写入硬盘时，移动队头指针。

## redo log日志文件的作用
redo log日志文件的作用是保证MySQL宕机后，数据可以恢复到宕机前的状态。当MySQL宕机后，InnoDB引擎会读取redo log日志文件中的内容，将数据恢复到宕机前的状态。
> 有了redo log日志文件，InnoDB引擎就可以保证即使数据库异常重启，之前提交的数据也不会丢失，这个能力成为crash-safe能力。整个过程用到的技术称之为WAL(Write-Ahead Logging)技术。即先写日志，再写磁盘.

# 重要的日志文件：binlog日志 todo

前面说redo log是InnoDB引擎内置的日志文件，属于引擎层的日志文件，而binlog是MySQL Server层实现的日志文件，属于Server层的日志文件。binlog日志文件用于记录数据库的变更操作，可以用于数据恢复和数据同步。

## binlog与redolog的对比
1. redolog是InnoDB引擎特有的日志文件；binlog是MySQL Server层实现的日志文件，所有的引擎都可以使用
2. redolog是物理日志，记录的是数据页的物理修改，而不是SQL语句；binlog是逻辑日志，记录的是语句的原始逻辑，如给ID=1这一行的字段加1，
3. redolog是循环写入，空间固定会用完；binlog是可以追加写入

## 执行器和InnoDB执行一条更新语句的过程

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

执行过程如下图：

![执行器和InnoDB执行一条更新语句的过程](../image/mysql/mysql日志体系/更新语句执行顺序.webp)

最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。

# 如何根据redo log日志文件和binlog日志文件恢复数据 

由于binlog会记录所有的逻辑操作，并且采用“追加写”的方式，所以恢复数据时，只需要将binlog中的操作重新执行一遍即可。

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，可以这么做：
1. 首先，找到最近的一次全量备份，如果运气好，可能就是前一天晚上的一个备份，从这个备份恢复到临时库；
2. 然后从备份的时间点开始，将备份的binlog依次取出，重放到中午误删表之前的那个时刻；

这样就跟误删之前的线上库一致了，然后可以把表数据从临时库取出来，按需要恢复到线上库去。


## 这里好像只使用了binlog，没有使用redo log，为什么还需要两阶段提交呢？

由于binlog和redolog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者反过来，看看这两种方式会有什么问题

假设当前ID=2的行，字段c的值是 0，再假设update语句过程中再写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？

1. 先写完redo log后写binlog，数据虽然能恢复回来，恢复后c=1，但是binlog中没有记录这个语句，之后备份日志的时候，存起来的binlog里面没有这条语句，后面假设又发生了宕机事故，从binlog恢复数据的时候，恢复出来的数据是c=0的，也就是最终恢复出来的数据是脏数据。
2. 先写完binlog后写redo log，如果binlog写完，数据库异常重启，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0，但是binlog里面已经记录了“把c从0改成1”这个日志，所以在之后用binlog来恢复的时候就多一个事务出来，恢复出来的这一行c的值就是1，与实际的值c=0不一致，也造成了数据不一致。

两阶段提交可以很好地解决上述两种“先写redo log或先写binlog可能导致数据不一致”的问题，它的核心就是将redo log的写入分为prepare和commit两个阶段，并配合binlog的写入，保证了binlog和redo log的一致性。具体来说：

1. 首先写redo log的prepare阶段，此时表示即将要提交，但事务还没最终完成；
2. 然后写binlog，且写入成功；
3. 最后再把redo log的状态改为commit，标志事务真正提交完成。

### 针对上述两种情况，采用两阶段提交后数据如何保证一致性？

- **假如在写完redo log的prepare阶段后，binlog还没写完时发生crash**  
  数据库重启恢复时，会发现redo log只有prepare没有commit，这个事务会被认定为未提交，不会做数据恢复，这样也不会有“binlog没有该操作，但redo log恢复后数据改变”的问题。

- **假如写完binlog但redo log还没commit时发生crash**  
  数据库重启后同样会检查redo log的状态，发现该事务只出了prepare没有commit，也会回滚这个事务，binlog虽然有记录，但是应用binlog恢复时，会发现redo log没有commit，这同样不会把事务应用到最终数据中，保证了数据和备份的一致性。

通过这种机制，可以保证**不管在哪一步宕机重启，redo log和binlog都能保持严格的一致性，数据不会丢失，也不会多出来，既保证了crash-safe，也保证了主从和备份恢复的一致性**。



**所以需要两阶段提交，先写完redo log再写binlog，这样才能保证数据的一致性。**


# 小结

- 学习了redo log日志文件和binlog日志文件的结构和作用
- 学习了binlog与redolog的对比
- 学习了执行器和InnoDB执行一条更新语句的过程
- 学习了如何根据redo log日志文件和binlog日志文件恢复数据
- 学习了两阶段提交的原理和实现以及其必要性

# 参考资料
极客时间《MySQL实战45讲》课程


