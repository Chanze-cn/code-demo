# MySQL 普通索引和唯一索引的区别

## 查询性能差异

### 查询过程对比

![两棵树示意图](./image/两棵树示意图.webp)

对于查询语句 `select * from T where k=5`，查询过程会先在索引树上查找，从树根一直找到对应满足条件的叶子节点（右图右下角），找到 `(5,500)` 这个记录。

**普通索引：**
- 查找到满足条件的第一个记录后，需要继续查找下一个记录
- 直到碰到第一个不满足 `k=5` 条件的记录才停止

**唯一索引：**
- 由于索引定义了唯一性，查找到第一个满足条件的记录后，就会立即停止检索

### 性能影响分析

**但是，这两者不同带来的性能差距是微乎其微的。**

原因在于 InnoDB 的数据是按照数据页为单位读写的。也就是说，当需要读一条记录的时候，并不是将这条记录本身从磁盘读出来，而是将这条记录所在的页读入内存中。

因此，当找到 `k=5` 的记录后，所在的数据页都已经在内存中，那么多做一次"查找并判断下一条记录"的操作，只需要一次指针寻找和一次计算，性能开销几乎可以忽略不计。


## 更新性能差异

### Change Buffer 机制

当需要更新一个数据页的时候：
- **数据页在内存中**：直接更新
- **数据页不在内存中**：在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 `change buffer` 中，这样就不需要从磁盘中读入这个数据页了

在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 `change buffer` 中与这个页有关的操作。

> **注意**：虽然名字叫做 change buffer，实际上它是可以持久化的数据。也就是说 change buffer 在内存中有拷贝，也会被写入到磁盘上。

**Merge 操作：**
- 将 `change buffer` 中的操作应用到原数据页，得到最新结果的过程称为 `merge`
- 触发 merge 的时机：
  - 访问这个数据页时会触发 merge
  - 系统后台线程会定期 merge
  - 数据库正常关闭的过程中，也会执行 merge 操作

**性能优势：**
- 将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显提升
- 数据读入内存需要占用 buffer pool，这种方式能避免占用内存，提高内存利用率

### Change Buffer 的使用限制

**唯一索引不能使用 change buffer：**
- 对于唯一索引，在插入的时候需要判断数据库中是否已存在该值
- 这个判断操作势必会读磁盘该数据页进行判断
- 因此唯一索引的更新不使用 change buffer

**结论：唯一索引的更新不能使用 change buffer，实际上只有普通索引可以使用。**


### 更新过程对比示例

如果要在这张表插入一个新记录 `(4,400)`，InnoDB 的处理流程如下：

#### 情况 1：数据页已经在内存中

- **唯一索引**：找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束
- **普通索引**：找到 3 和 5 之间的位置，插入这个值，语句执行结束

**结论**：两种索引的性能差异很小。

#### 情况 2：数据页不在内存中

- **唯一索引**：需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束
  - 需要一次磁盘随机读操作
- **普通索引**：将更新记录在 `change buffer` 中，语句执行结束
  - 不需要读磁盘，性能明显提升

**结论**：普通索引在这种情况下性能更优，避免了磁盘随机读操作。

### Change Buffer 的使用场景

**适用场景：**
- Change buffer 主要目的是将记录的变更动作缓存下来，在一次磁盘 IO 操作中一次性 merge
- 在 merge 操作之前，change buffer 记录的变更越多，收益就越大
- **读少写多的业务**：页面在写完以后立马被访问到的概率比较小，此时 `change buffer` 的使用效果最好
  - 典型场景：账单类、日志类的系统

**不适用场景：**
- **写后立即查询的业务**：更新完之后立马做查询的业务场景下
  - `change buffer` 不仅没有减少 IO 访问次数
  - 反而增加了 `change buffer` 的维护成本，起了反作用